= Chapter 5: MicroProfile Configuration

This chapter focuses on MicroProfile Configuration, a key feature that allows developers to externalize configuration properties from their code. You can adapt configuration parameters to different environments (development, testing, production) without altering the core code. It provides flexibility and adaptability for microservices in different environments. 

== Topics to be covered

- Understanding MicroProfile Configuration
- Different environments required for Microservices development 
- Working with Various Configuration Sources
- Key capabilities of MicroProfile Configuration
- Implementing Configuration Properties
- Creating a Custom Configuration Source
- Dynamic Updates and Handling Configuration Change Events
- Managing Configuration for Different Environments
- Securing Configuration and Best Practices

== Understanding MicroProfile Configuration

*MicroProfile Configuration* is a specification that allows developers to inject configuration values into applications. The MicroProfile Configuration APIs will enable developers to externalize configuration and access it from within your application. By separating configuration data (like database URLs, API credentials, feature flags) from the codebase, you make it easier to modify these settings without recompiling and redeploying the application. 

For instance, with MicroProfile Config, you can configure connection settings for a database enhancing flexibility and adaptability across different environments in our MicroProfile e-commerce application. You can update configurations seamlessly, sometimes even while the application is running (for dynamic config sources), minimizing downtime and streamlining deployment processes. This is essential for microservices that may run in diverse setups. 

== Different environments required for Microservices development

When developing microservices, it’s essential to establish various
environments to accommodate different stages of the development
lifecycle. Each environment serves distinct purposes, ensuring the
application is thoroughly tested, secure, and efficient before its
deployment to production. Below are the critical environments typically
set up for developing microservices:

- *Development Environment*—Developers write new code, implement features,
and perform basic unit testing in this environment, which is where the
initial development occurs. This environment is usually configured to
use local or development databases with dummy data for testing. The
logging level used in this environment is generally verbose for
debugging purposes.

- *Testing or QA Environment*—This environment is dedicated to rigorous
testing, including automated tests, integration tests, and manual
testing by QA engineers to identify bugs or issues. Configuration here
mirrors production settings as closely as possible and connects to a
testing database. For error tracing, detailed logging may be enabled in
this environment.

- *Staging Environment*—This is a production-like environment for final
testing of the changes before deployment to production. It ensures that
your microservices perform as expected under production conditions. This
environment is configured with settings identical to the production
environment. It typically uses a copy of production data that is
sanitized of sensitive data.

- *Production Environment*—This is the live environment where the
microservice is fully deployed and accessible to end-users. It’s
optimized for security, performance, and reliability and configured to
access actual user data with all security features fully enabled.
Performance monitoring tools are also set up here to ensure smooth
operations.

Using the above set of environments, development teams can streamline
the development process, enhance quality, and ensure the microservices
are robust and ready for production use. Your development team may also
require additional environments for specific needs like automation,
penetration testing, and stress testing, depending on the unique needs
of the microservices.

== Working with Various Configuration Sources

MicroProfile Config allows applications to retrieve configuration
properties from a variety of sources. By default, MicroProfile Config
includes various built-in configuration sources, but you can also define
custom sources. Below we discuss how to work with these various
configuration sources.

=== Built-in Configuration Sources

MicroProfile Config defines default configuration sources that are
automatically enabled:

*System Properties:* Configuration values defined as system properties
can be accessed by MicroProfile Config. These properties can be set at
runtime using the `-D` flag when starting the JVM.

*Environment Variables:* Environment variables available in the system
can be used as configuration sources. They are useful for setting
configuration properties external to the application, especially in
containerized environments.

*MicroProfile Config Properties File:* A properties file named
_microprofile-config.properties_ can be placed in the _META-INF_ directory
of your application. This file is particularly useful for setting
default configuration values that ship with the application.

== Types of Configuration Sources

A *static configuration source* is the one where the data does not change once the application has started. Examples include the microprofile-config.properties file and most custom implementations that read from a database or a service at startup. 

On the other hand, *a dynamic configuration source* is one that can change its data at runtime. System properties and some custom implementations that periodically check for changes in a remote configuration service are examples of dynamic sources.

MicroProfile Config allows applications to read from these dynamic sources as easily as from static ones. However, whether a configuration source supports dynamic behavior depends on its implementation.

== Key capabilities of MicroProfile Configuration

The MicroProfile Configuration specifications offer a set of APIs that
enable you to handle your application’s configuration efficiently. They
allow you to easily manage and customize your application’s
configurations, making it a valuable tool for developers.

The MicroProfile Configuration APIs provide the following capabilities
for managing the configuration settings of your application:

- It allows reading and writing configuration values.
- It allows applications to retrieve configuration values reliably,
supporting various sources, such as property files, system properties,
environment variables, and more.
- Observe changes to configuration values using config events, making
tracking and managing changes to your application’s configuration
easier.

The MicroProfile Configuration API provides several classes, allowing
easy integration of configuration values. Below is the list of key
classes and interfaces included in the MicroProfile Configuration API:

- `Config` - the class that is the main entry point to the configuration API
and provides access to configuration data. The Config class provides
static methods that can be used to access configuration properties.
- `ConfigProvider` - a utility class for getting the Config instance. It
allows retrieving the static instance of the Config object.
- `ConfigBuilder` - An interface used to create a Config instance manually.
It can add default sources, converters, and configuration sources.
- `ConfigSource` - This class represents a source of configuration values.
It reads configuration data from a specific source, such as system
properties, environment variables, files, or data stores.
- `Property` - It represents a key/value pair in the configuration data.
- `Converter<T>` - This interface implements custom converters that convert
configuration values from String to any desired type.
- `PropertyExpression` - An interface supporting expression evaluation
within configuration values, allowing dynamic substitution.

These classes and interfaces provide a robust configuration mechanism
that is easy to use and extend. Developers can leverage these APIs to
externalize configuration from their applications, making them more
flexible and more accessible to run in different environments.

== Implementing Configuration Properties

The Config API allows you to define configuration properties in many ways, including property files, environment variables, and system properties. To use the Config API, we’ll need to include the following dependency in our _pom.xml_ file:

[source, xml]
----
<dependency>
  <groupId>org.eclipse.microprofile.config</groupId>
  <artifactId>microprofile-config-api</artifactId>
  <version>3.1</version>
</dependency>
----

For Gradle, modify your _build.gradle_ file with the following dependency: 

[source]
----
implementation 'org.eclipse.microprofile.config:microprofile-config-api:3.1'
----

Let’s now modify the `getProducts()` method to return a `jakarta.ws.rs.core.Response` object instead of a list of Product entities directly, we can utilize the `Response` class to build our response.  This approach allows for a more standardized and flexible API response handling, including the ability to set HTTP status codes and headers. 

Lets create a configuration file with the name _microprofile-config.properties_ and the content as below: 

[source]
----
# microprofile-config.properties
product.maintenanceMode=false
----

This configuration file should be placed in the _src/main/resources/META-INF/_ directory of your application.

=== Reading Configuration Properties

Next inject this configuration value to a private variable in the ProductResource and consume this within all the operations of this service.

MicroProfile Config will automatically detect and use the properties defined in this file, allowing you to externalize configuration and easily adjust the behavior of your application based on the environment in which it is deployed.

Below is the updated `ProductResource` class and `getProducts()` method:

[source, java]
----
package io.microprofile.tutorial.store.product.resource;

import io.microprofile.tutorial.store.product.entity.Product;
import io.microprofile.tutorial.store.product.repository.ProductRepository;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.transaction.Transactional;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;

import org.eclipse.microprofile.config.inject.ConfigProperty;
import org.eclipse.microprofile.openapi.annotations.Operation;
import org.eclipse.microprofile.openapi.annotations.media.Content;
import org.eclipse.microprofile.openapi.annotations.media.Schema;

import org.eclipse.microprofile.openapi.annotations.responses.APIResponse;
import org.eclipse.microprofile.openapi.annotations.responses.APIResponses;

import java.util.List;

@Path("/products")
@ApplicationScoped
public class ProductResource {

   @Inject
   @ConfigProperty(name="product.maintenanceMode", defaultValue="false")
   private boolean maintenanceMode;
  
   @Inject
   private ProductRepository productRepository;

   @GET
   @Produces(MediaType.APPLICATION_JSON)
   @Transactional
   
   // OpenAPI code 
   // … 
   
   public Response getProducts() {

       List<Product> products = productRepository.findAllProducts();

       // If in maintenance mode, return Service Unavailable status
       if (maintenanceMode) {
          return Response
                  .status(Response.Status.SERVICE_UNAVAILABLE)
                  .entity("The product catalog service is currently in maintenance mode. Please try again later.")
                  .build();

       // If products found, return products and OK status
       } else if (products != null && !products.isEmpty()) {
           return Response
                   .status(Response.Status.OK)
                   .entity(products).build();

      // If products not found, return Not Found status and message
      } else {
          return Response
                  .status(Response.Status.NOT_FOUND)
                  .entity("No products found")
                  .build();
      }
   }
}
----

Explanation: 

- `@Inject`: This CDI annotation enables dependency injection. It tells the container to inject an instance of a specified bean at runtime. As we have learnt previously, dependency injection enables loose coupling between classes and their dependencies, making the code more modular, easier to test, and maintain.

- `@ConfigProperty(name="product.maintenanceMode", defaultValue="false")`: This MicroProfile Config annotation used along with `@Inject` to inject configuration property values into beans. It allows developers to externalize configuration from the application code, making applications more flexible and environment-agnostic. The `name` parameter specifies the key of the configuration property to be injected. In this case, `product.maintenanceMode` is the key for a property that controls whether this service is in maintenance mode. The `defaultValue` provides a default value to be used if the specified configuration property is not found in any of the configured sources. Here, the default value is `false`, indicating that, by default, the service is not in maintenance mode unless explicitly configured otherwise.
- `private boolean maintenanceMode`: This field is set to the value of the `product.maintenanceMode` configuration property. Due to the `defaultValue ="false"`, if the configuration is not specified elsewhere, `maintenanceMode` will be `false`, meaning the service operates normally.

- `private ProductRepository productRepository`: This field is injected with an instance of ProductRepository.  This class abstracts the data access operations for products. This injection decouples the class from the specific implementation of the repository, making the code more modular and easier to adapt or replace parts of it in the future.

- The `getProducts()` method retrieves all products from the repository by calling `productRepository.findAllProducts()`, which queries the database to retrieve a list of all available products.
Before proceeding to return the list of products, the method checks the `maintenanceMode` flag. If `maintenanceMode` is `true`, the service is currently undergoing maintenance, and thus, it is not appropriate to perform regular operations. The method constructs and returns a Response with a `503 Service Unavailable` HTTP status code, along with a message indicating that the product catalog service is in maintenance mode.

- If the service is not in maintenance mode, then the method checks if the list of retrieved products is not `null` and not empty. 

- If products are found, it constructs a Response with a status of `200 OK` and includes the list of products as the response entity. This indicates a successful operation where product data is found and returned. 

- If the products list is`null` or empty, indicating no products were found, the method constructs and returns a `Response` with a `404 Not Found` status code and a message stating that no products were found.

When we deploy the application and invoke the `/api/products` endpoint, we should see the list of products as below:

[source, json]
----
[{"description":"Apple iPhone 15 Pro","id":1,"name":"iPhone 15 Pro","price":999.0}]
----

=== Specifying Default Values for a `ConfigProperty`

For non-critical properties, providing a default value using the defaultValue attribute of the @ConfigProperty annotation ensures that your application has a fallback option. We can specify a default value to be used if the property does not exist as below:

[source, java]
----
public class ProductResource {

   @Inject
   @ConfigProperty(name="product.maintenanceMode", defaultValue="false")
   private boolean maintenanceMode;
   … 
----

In the example above , the `false` default value will be used if the `product.maintenanceMode` property does not exist.

=== Type Conversion in `ConfigProperty`

`ConfigProperty` also supports type conversion, so we can inject our configuration data into fields of any type:

[source, java]
----
   @Inject
   @ConfigProperty(name="product.maintenanceMode", defaultValue="false")
   private boolean maintenanceMode;
----

In this example, the `product.maintenanceMode` property will be converted to an `Boolean` before it is injected into the `maintenanceMode` field. If the conversion fails, a `org.eclipse.microprofile.config.ConversionFailedException` will be thrown.

=== Converting Configuration data to a POJO

We can also use the Config API to convert our configuration data to a POJO:

[source, java]
----
import org.eclipse.microprofile.config.inject.ConfigProperty;


public class MyApplication {
    @Inject
    private MaintenanceMessage message;
}


public class MaintenanceMessage {
    @ConfigProperty(name="product.maintenanceMessage")
    private String message;
}
----

In this example, we’re injecting a property named "product.maintenanceMessage" into the message field of our MaintenanceMessage class. If the property does not exist, a `org.eclipse.microprofile.config.ConfigPropertyNotFoundException` will be thrown.

=== Creating a Custom `ConfigSource`

As we saw, the Config API makes it easy to inject configuration properties into an application. The Config API defines a contract for config implementations. A ConfigSource is used to read configuration data from a particular source. For example, we could create a ConfigSource that reads configuration data from a file.

`ConfigSource` interface has the following methods: 
- `String getName()` : Returns the name of the ConfigSource. 
- `int getOrdinal()` : Returns the ordinal of the ConfigSource. Ordinals are used to determine the precedence of ConfigSources. A higher ordinal means a higher precedence. 
- `Map<String, String> getProperties()` : Returns a map of the properties in this ConfigSource. The keys in the map are the property names, and the values are the property values. 
- `getValue(String propertyName)` : Returns the value of the given property. If the property is not found, this method returns null. 
- `Set getPropertyNames()` : Returns a Set of the property names in this ConfigSource.

Let’s implement a feature in our MicroProfile e-Commerce application to integrate payment gateway configuration dynamically by creating a PaymentServiceConfigSource (a custom ConfigSource) which could fetch API keys and endpoints. This would ensure that payment service configurations are up-to-date and can be changed without redeploying the application.

MicroProfile Config provides a flexible framework for integrating with various external configuration providers, enabling applications to load configurations from sources beyond the default system properties, environment variables, and microprofile-config.properties files. This capability is crucial for modern applications that may need to pull configuration from dynamic sources like cloud services, databases, or custom APIs.

The following is an implementation of a `ConfigSource` that reads configuration data from a file:

[source, java]
----
package io.microprofile.tutorial.store.payment.config;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import org.eclipse.microprofile.config.spi.ConfigSource;

public class PaymentServiceConfigSource implements ConfigSource{
  
   private Map<String, String> properties = new HashMap<>();

   public PaymentServiceConfigSource() {
       // Load payment service configurations dynamically
       // This example uses hardcoded values for demonstration
       properties.put("payment.gateway.apiKey", "secret_api_key");
       properties.put("payment.gateway.endpoint", "https://api.paymentgateway.com");
   }

   @Override
   public Map<String, String> getProperties() {
       return properties;
   }

   @Override
   public String getValue(String propertyName) {
       return properties.get(propertyName);
   }

   @Override
   public String getName() {
       return "PaymentServiceConfigSource";
   }

   @Override
   public int getOrdinal() {
       // Ensuring high priority to override default configurations if necessary
       return 600;
   }

   @Override
   public Set<String> getPropertyNames() {
       // Return the set of all property names available in this config source
       return properties.keySet();}
}
----

NOTE: When integrating with external configuration providers, it’s essential to consider security aspects, especially when dealing with sensitive configuration data. Use secure communication channels (e.g., HTTPS) to retrieve configuration from external services. Manage access control meticulously to prevent unauthorized access to sensitive configuration. Consider encrypting sensitive configuration values and decrypting them within your ConfigSource or application logic.
